
<!DOCTYPE html>
<html>
<head></head> 
<body>
  <script>
    (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/fft.js/lib/fft.js
  var require_fft = __commonJS({
    "node_modules/fft.js/lib/fft.js"(exports, module) {
      "use strict";
      function FFT2(size) {
        this.size = size | 0;
        if (this.size <= 1 || (this.size & this.size - 1) !== 0)
          throw new Error("FFT size must be a power of two and bigger than 1");
        this._csize = size << 1;
        var table = new Array(this.size * 2);
        for (var i = 0; i < table.length; i += 2) {
          const angle = Math.PI * i / this.size;
          table[i] = Math.cos(angle);
          table[i + 1] = -Math.sin(angle);
        }
        this.table = table;
        var power = 0;
        for (var t = 1; this.size > t; t <<= 1)
          power++;
        this._width = power % 2 === 0 ? power - 1 : power;
        this._bitrev = new Array(1 << this._width);
        for (var j = 0; j < this._bitrev.length; j++) {
          this._bitrev[j] = 0;
          for (var shift = 0; shift < this._width; shift += 2) {
            var revShift = this._width - shift - 2;
            this._bitrev[j] |= (j >>> shift & 3) << revShift;
          }
        }
        this._out = null;
        this._data = null;
        this._inv = 0;
      }
      module.exports = FFT2;
      FFT2.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
        var res = storage || new Array(complex.length >>> 1);
        for (var i = 0; i < complex.length; i += 2)
          res[i >>> 1] = complex[i];
        return res;
      };
      FFT2.prototype.createComplexArray = function createComplexArray() {
        const res = new Array(this._csize);
        for (var i = 0; i < res.length; i++)
          res[i] = 0;
        return res;
      };
      FFT2.prototype.toComplexArray = function toComplexArray(input, storage) {
        var res = storage || this.createComplexArray();
        for (var i = 0; i < res.length; i += 2) {
          res[i] = input[i >>> 1];
          res[i + 1] = 0;
        }
        return res;
      };
      FFT2.prototype.completeSpectrum = function completeSpectrum(spectrum) {
        var size = this._csize;
        var half = size >>> 1;
        for (var i = 2; i < half; i += 2) {
          spectrum[size - i] = spectrum[i];
          spectrum[size - i + 1] = -spectrum[i + 1];
        }
      };
      FFT2.prototype.transform = function transform(out, data) {
        if (out === data)
          throw new Error("Input and output buffers must be different");
        this._out = out;
        this._data = data;
        this._inv = 0;
        this._transform4();
        this._out = null;
        this._data = null;
      };
      FFT2.prototype.realTransform = function realTransform(out, data) {
        if (out === data)
          throw new Error("Input and output buffers must be different");
        this._out = out;
        this._data = data;
        this._inv = 0;
        this._realTransform4();
        this._out = null;
        this._data = null;
      };
      FFT2.prototype.inverseTransform = function inverseTransform(out, data) {
        if (out === data)
          throw new Error("Input and output buffers must be different");
        this._out = out;
        this._data = data;
        this._inv = 1;
        this._transform4();
        for (var i = 0; i < out.length; i++)
          out[i] /= this.size;
        this._out = null;
        this._data = null;
      };
      FFT2.prototype._transform4 = function _transform4() {
        var out = this._out;
        var size = this._csize;
        var width = this._width;
        var step = 1 << width;
        var len = size / step << 1;
        var outOff;
        var t;
        var bitrev = this._bitrev;
        if (len === 4) {
          for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
            const off = bitrev[t];
            this._singleTransform2(outOff, off, step);
          }
        } else {
          for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
            const off = bitrev[t];
            this._singleTransform4(outOff, off, step);
          }
        }
        var inv = this._inv ? -1 : 1;
        var table = this.table;
        for (step >>= 2; step >= 2; step >>= 2) {
          len = size / step << 1;
          var quarterLen = len >>> 2;
          for (outOff = 0; outOff < size; outOff += len) {
            var limit = outOff + quarterLen;
            for (var i = outOff, k = 0; i < limit; i += 2, k += step) {
              const A = i;
              const B = A + quarterLen;
              const C = B + quarterLen;
              const D = C + quarterLen;
              const Ar = out[A];
              const Ai = out[A + 1];
              const Br = out[B];
              const Bi = out[B + 1];
              const Cr = out[C];
              const Ci = out[C + 1];
              const Dr = out[D];
              const Di = out[D + 1];
              const MAr = Ar;
              const MAi = Ai;
              const tableBr = table[k];
              const tableBi = inv * table[k + 1];
              const MBr = Br * tableBr - Bi * tableBi;
              const MBi = Br * tableBi + Bi * tableBr;
              const tableCr = table[2 * k];
              const tableCi = inv * table[2 * k + 1];
              const MCr = Cr * tableCr - Ci * tableCi;
              const MCi = Cr * tableCi + Ci * tableCr;
              const tableDr = table[3 * k];
              const tableDi = inv * table[3 * k + 1];
              const MDr = Dr * tableDr - Di * tableDi;
              const MDi = Dr * tableDi + Di * tableDr;
              const T0r = MAr + MCr;
              const T0i = MAi + MCi;
              const T1r = MAr - MCr;
              const T1i = MAi - MCi;
              const T2r = MBr + MDr;
              const T2i = MBi + MDi;
              const T3r = inv * (MBr - MDr);
              const T3i = inv * (MBi - MDi);
              const FAr = T0r + T2r;
              const FAi = T0i + T2i;
              const FCr = T0r - T2r;
              const FCi = T0i - T2i;
              const FBr = T1r + T3i;
              const FBi = T1i - T3r;
              const FDr = T1r - T3i;
              const FDi = T1i + T3r;
              out[A] = FAr;
              out[A + 1] = FAi;
              out[B] = FBr;
              out[B + 1] = FBi;
              out[C] = FCr;
              out[C + 1] = FCi;
              out[D] = FDr;
              out[D + 1] = FDi;
            }
          }
        }
      };
      FFT2.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {
        const out = this._out;
        const data = this._data;
        const evenR = data[off];
        const evenI = data[off + 1];
        const oddR = data[off + step];
        const oddI = data[off + step + 1];
        const leftR = evenR + oddR;
        const leftI = evenI + oddI;
        const rightR = evenR - oddR;
        const rightI = evenI - oddI;
        out[outOff] = leftR;
        out[outOff + 1] = leftI;
        out[outOff + 2] = rightR;
        out[outOff + 3] = rightI;
      };
      FFT2.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
        const out = this._out;
        const data = this._data;
        const inv = this._inv ? -1 : 1;
        const step2 = step * 2;
        const step3 = step * 3;
        const Ar = data[off];
        const Ai = data[off + 1];
        const Br = data[off + step];
        const Bi = data[off + step + 1];
        const Cr = data[off + step2];
        const Ci = data[off + step2 + 1];
        const Dr = data[off + step3];
        const Di = data[off + step3 + 1];
        const T0r = Ar + Cr;
        const T0i = Ai + Ci;
        const T1r = Ar - Cr;
        const T1i = Ai - Ci;
        const T2r = Br + Dr;
        const T2i = Bi + Di;
        const T3r = inv * (Br - Dr);
        const T3i = inv * (Bi - Di);
        const FAr = T0r + T2r;
        const FAi = T0i + T2i;
        const FBr = T1r + T3i;
        const FBi = T1i - T3r;
        const FCr = T0r - T2r;
        const FCi = T0i - T2i;
        const FDr = T1r - T3i;
        const FDi = T1i + T3r;
        out[outOff] = FAr;
        out[outOff + 1] = FAi;
        out[outOff + 2] = FBr;
        out[outOff + 3] = FBi;
        out[outOff + 4] = FCr;
        out[outOff + 5] = FCi;
        out[outOff + 6] = FDr;
        out[outOff + 7] = FDi;
      };
      FFT2.prototype._realTransform4 = function _realTransform4() {
        var out = this._out;
        var size = this._csize;
        var width = this._width;
        var step = 1 << width;
        var len = size / step << 1;
        var outOff;
        var t;
        var bitrev = this._bitrev;
        if (len === 4) {
          for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
            const off = bitrev[t];
            this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
          }
        } else {
          for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
            const off = bitrev[t];
            this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
          }
        }
        var inv = this._inv ? -1 : 1;
        var table = this.table;
        for (step >>= 2; step >= 2; step >>= 2) {
          len = size / step << 1;
          var halfLen = len >>> 1;
          var quarterLen = halfLen >>> 1;
          var hquarterLen = quarterLen >>> 1;
          for (outOff = 0; outOff < size; outOff += len) {
            for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
              var A = outOff + i;
              var B = A + quarterLen;
              var C = B + quarterLen;
              var D = C + quarterLen;
              var Ar = out[A];
              var Ai = out[A + 1];
              var Br = out[B];
              var Bi = out[B + 1];
              var Cr = out[C];
              var Ci = out[C + 1];
              var Dr = out[D];
              var Di = out[D + 1];
              var MAr = Ar;
              var MAi = Ai;
              var tableBr = table[k];
              var tableBi = inv * table[k + 1];
              var MBr = Br * tableBr - Bi * tableBi;
              var MBi = Br * tableBi + Bi * tableBr;
              var tableCr = table[2 * k];
              var tableCi = inv * table[2 * k + 1];
              var MCr = Cr * tableCr - Ci * tableCi;
              var MCi = Cr * tableCi + Ci * tableCr;
              var tableDr = table[3 * k];
              var tableDi = inv * table[3 * k + 1];
              var MDr = Dr * tableDr - Di * tableDi;
              var MDi = Dr * tableDi + Di * tableDr;
              var T0r = MAr + MCr;
              var T0i = MAi + MCi;
              var T1r = MAr - MCr;
              var T1i = MAi - MCi;
              var T2r = MBr + MDr;
              var T2i = MBi + MDi;
              var T3r = inv * (MBr - MDr);
              var T3i = inv * (MBi - MDi);
              var FAr = T0r + T2r;
              var FAi = T0i + T2i;
              var FBr = T1r + T3i;
              var FBi = T1i - T3r;
              out[A] = FAr;
              out[A + 1] = FAi;
              out[B] = FBr;
              out[B + 1] = FBi;
              if (i === 0) {
                var FCr = T0r - T2r;
                var FCi = T0i - T2i;
                out[C] = FCr;
                out[C + 1] = FCi;
                continue;
              }
              if (i === hquarterLen)
                continue;
              var ST0r = T1r;
              var ST0i = -T1i;
              var ST1r = T0r;
              var ST1i = -T0i;
              var ST2r = -inv * T3i;
              var ST2i = -inv * T3r;
              var ST3r = -inv * T2i;
              var ST3i = -inv * T2r;
              var SFAr = ST0r + ST2r;
              var SFAi = ST0i + ST2i;
              var SFBr = ST1r + ST3i;
              var SFBi = ST1i - ST3r;
              var SA = outOff + quarterLen - i;
              var SB = outOff + halfLen - i;
              out[SA] = SFAr;
              out[SA + 1] = SFAi;
              out[SB] = SFBr;
              out[SB + 1] = SFBi;
            }
          }
        }
      };
      FFT2.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {
        const out = this._out;
        const data = this._data;
        const evenR = data[off];
        const oddR = data[off + step];
        const leftR = evenR + oddR;
        const rightR = evenR - oddR;
        out[outOff] = leftR;
        out[outOff + 1] = 0;
        out[outOff + 2] = rightR;
        out[outOff + 3] = 0;
      };
      FFT2.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {
        const out = this._out;
        const data = this._data;
        const inv = this._inv ? -1 : 1;
        const step2 = step * 2;
        const step3 = step * 3;
        const Ar = data[off];
        const Br = data[off + step];
        const Cr = data[off + step2];
        const Dr = data[off + step3];
        const T0r = Ar + Cr;
        const T1r = Ar - Cr;
        const T2r = Br + Dr;
        const T3r = inv * (Br - Dr);
        const FAr = T0r + T2r;
        const FBr = T1r;
        const FBi = -T3r;
        const FCr = T0r - T2r;
        const FDr = T1r;
        const FDi = T3r;
        out[outOff] = FAr;
        out[outOff + 1] = 0;
        out[outOff + 2] = FBr;
        out[outOff + 3] = FBi;
        out[outOff + 4] = FCr;
        out[outOff + 5] = 0;
        out[outOff + 6] = FDr;
        out[outOff + 7] = FDi;
      };
    }
  });

  // node_modules/next-power-of-two/index.js
  var require_next_power_of_two = __commonJS({
    "node_modules/next-power-of-two/index.js"(exports, module) {
      module.exports = nextPowerOfTwo;
      function nextPowerOfTwo(n) {
        if (n === 0) return 1;
        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return n + 1;
      }
    }
  });

  // node_modules/ml-convolution/src/utils.js
  function checkSize(size) {
    if (!Number.isInteger(size) || size < 1) {
      throw new TypeError(`size must be a positive integer. Got ${size}`);
    }
  }
  function checkKernel(kernel) {
    if (kernel.length === 0 || kernel.length % 2 !== 1) {
      throw new RangeError(
        `kernel must have an odd positive length. Got ${kernel.length}`
      );
    }
  }
  function checkBorderType(borderType) {
    if (borderType !== "CONSTANT" && borderType !== "CUT") {
      throw new RangeError(`unexpected border type: ${borderType}`);
    }
  }
  function checkInputLength(actual, expected) {
    if (actual !== expected) {
      throw new RangeError(
        `input length (${actual}) does not match setup size (${expected})`
      );
    }
  }
  function createArray(len) {
    const array = [];
    for (var i = 0; i < len; i++) {
      array.push(0);
    }
    return array;
  }

  // node_modules/ml-convolution/src/fftConvolution.js
  var import_fft = __toESM(require_fft());
  var import_next_power_of_two = __toESM(require_next_power_of_two());
  var FFTConvolution = class {
    constructor(size, kernel, borderType = "CONSTANT") {
      checkSize(size);
      checkKernel(kernel);
      checkBorderType(borderType);
      this.size = size;
      this.kernelOffset = (kernel.length - 1) / 2;
      this.doubleOffset = 2 * this.kernelOffset;
      this.borderType = borderType;
      const resultLength = size + this.doubleOffset;
      this.fftLength = (0, import_next_power_of_two.default)(Math.max(resultLength, 2));
      this.fftComplexLength = this.fftLength * 2;
      this.fft = new import_fft.default(this.fftLength);
      kernel = kernel.slice().reverse();
      const paddedKernel = createArray(this.fftComplexLength);
      this.fftKernel = createArray(this.fftComplexLength);
      pad(kernel, paddedKernel, this.fftComplexLength);
      this.fft.transform(this.fftKernel, paddedKernel);
      this.paddedInput = createArray(this.fftComplexLength);
      this.fftInput = createArray(this.fftComplexLength);
      this.ifftOutput = createArray(this.fftComplexLength);
      this.result = paddedKernel;
    }
    convolve(input) {
      checkInputLength(input.length, this.size);
      pad(input, this.paddedInput, this.fftComplexLength);
      this.fft.transform(this.fftInput, this.paddedInput);
      for (var i = 0; i < this.fftInput.length; i += 2) {
        const tmp = this.fftInput[i] * this.fftKernel[i] - this.fftInput[i + 1] * this.fftKernel[i + 1];
        this.fftInput[i + 1] = this.fftInput[i] * this.fftKernel[i + 1] + this.fftInput[i + 1] * this.fftKernel[i];
        this.fftInput[i] = tmp;
      }
      this.fft.inverseTransform(this.ifftOutput, this.fftInput);
      const r = this.fft.fromComplexArray(this.ifftOutput, this.result);
      if (this.borderType === "CONSTANT") {
        return r.slice(this.kernelOffset, this.kernelOffset + input.length);
      } else {
        return r.slice(this.doubleOffset, input.length);
      }
    }
  };
  function fftConvolution(input, kernel, borderType) {
    return new FFTConvolution(input.length, kernel, borderType).convolve(input);
  }
  function pad(data, out, len) {
    let i = 0;
    for (; i < data.length; i++) {
      out[i * 2] = data[i];
      out[i * 2 + 1] = 0;
    }
    i *= 2;
    for (; i < len; i += 2) {
      out[i] = 0;
      out[i + 1] = 0;
    }
  }

  // src/interpolation.ts
  function lerp(x, a, b) {
    return a * (1 - x) + b * x;
  }
  function unlerp(x, a, b) {
    return (x - a) / (b - a);
  }
  function rescale(x, a1, b1, a2, b2) {
    return lerp(unlerp(x, a1, b1), a2, b2);
  }
  function clamp(x, lo, hi) {
    return Math.max(Math.min(x, hi), lo);
  }

  // src/range.ts
  function range(hi) {
    let arr = [];
    for (let i = 0; i < hi && i < 1e7; i++) {
      arr.push(i);
    }
    return arr;
  }

  // src/audio/audio.ts
  function signal(duration, f, sampleRate = 44100) {
    const data = new Float32Array(
      range(duration * sampleRate).map((x) => f(x / sampleRate, x))
    );
    return {
      sampleRate,
      channels: [data, new Float32Array(data)]
    };
  }
  function sine(duration, freq, amp, phase = 0, sampleRate = 44100) {
    return signal(
      duration,
      (x) => Math.sin((x - phase) * Math.PI * 2 * freq) * amp
    );
  }
  function silence(duration, sampleRate = 44100) {
    return constant(duration, 0, sampleRate);
  }
  function constant(duration, c, sampleRate = 44100) {
    const data = new Float32Array(range(duration * sampleRate).map(() => c));
    return {
      sampleRate,
      channels: [data, new Float32Array(data)]
    };
  }
  function play(audio, audioContext) {
    const actx = audioContext ?? new AudioContext();
    const buf = actx.createBuffer(
      audio.channels.length,
      audio.channels[0].length,
      audio.sampleRate
    );
    for (let i = 0; i < audio.channels.length; i++) {
      buf.copyToChannel(audio.channels[i], i, 0);
    }
    const source = actx.createBufferSource();
    source.buffer = buf;
    source.connect(actx.destination);
    source.start();
  }
  function resample(audio, newSampleRate) {
    let newSampleCount = audio.channels[0].length / audio.sampleRate * newSampleRate;
    let channels = [];
    for (const c of audio.channels) {
      channels.push(
        new Float32Array(
          range(newSampleCount).map((i) => {
            const oldIndex = clamp(
              i / newSampleRate * audio.sampleRate,
              0,
              audio.channels[0].length
            );
            const lo = Math.floor(oldIndex);
            const hi = Math.ceil(oldIndex);
            const frac = oldIndex % 1;
            return c[lo] * (1 - frac) + c[hi] * frac;
          })
        )
      );
    }
    return {
      sampleRate: newSampleRate,
      channels
    };
  }
  function add(a, b, offsetB = 0) {
    if (b.sampleRate !== a.sampleRate) {
      b = resample(b, a.sampleRate);
    }
    const offsetSamples = Math.floor(offsetB * a.sampleRate);
    for (let ci = 0; ci < a.channels.length; ci++) {
      for (let i = 0; i < b.channels[ci].length; i++) {
        a.channels[ci][i + offsetSamples] += b.channels[ci][i];
      }
    }
    return a;
  }
  function modulateGain(a, envelope2, offsetB = 0) {
    if (envelope2.sampleRate !== a.sampleRate) {
      envelope2 = resample(envelope2, a.sampleRate);
    }
    const offsetSamples = Math.floor(offsetB * a.sampleRate);
    for (let ci = 0; ci < a.channels.length; ci++) {
      for (let i = 0; i < envelope2.channels[ci].length; i++) {
        a.channels[ci][i + offsetSamples] *= envelope2.channels[ci][i];
      }
    }
    return a;
  }
  function adsr(a, d, s, r, ag = 1, dg = 0.5, sg = 0.5, rg = 0, sampleRate = 44100) {
    const duration = a + d + s + r;
    return signal(
      duration,
      (x) => {
        if (x < a) {
          return rescale(x, 0, a, 0, ag);
        }
        if (x < a + d) {
          return rescale(x, a, a + d, ag, dg);
        }
        if (x < a + d + s) {
          return rescale(x, a + d, a + d + s, dg, sg);
        }
        return rescale(x, a + d + s, a + d + s + r, sg, rg);
      },
      sampleRate
    );
  }
  function scaleDuration(a, duration, newSampleRate = 44100) {
    const sampleCount = duration * newSampleRate;
    const channels = [];
    for (const c of a.channels) {
      channels.push(
        new Float32Array(
          range(sampleCount).map((i) => {
            const idx = i / newSampleRate / duration * c.length;
            const lo = Math.floor(idx);
            const hi = Math.ceil(idx);
            return lerp(idx % 1, c[lo], c[hi]);
          })
        )
      );
    }
    return { channels, sampleRate: newSampleRate };
  }
  function convolve(a, kernel) {
    return {
      channels: range(a.channels.length).map(
        (i) => new Float32Array(
          fftConvolution(
            a.channels[i],
            kernel.channels[i].length % 2 == 0 ? [...kernel.channels[i], 0] : kernel.channels[i]
          )
        )
      ),
      sampleRate: a.sampleRate
    };
  }
  function graphAudio(a, width, height) {
    const canvas = document.createElement("canvas");
    const channelWidth = width;
    const channelHeight = height / a.channels.length;
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    let ci = 0;
    for (const c of a.channels) {
      ctx?.beginPath();
      let miny = channelHeight * ci;
      let maxy = channelHeight * (ci + 1);
      for (let i = 0; i < c.length; i++) {
        let x = i / c.length * width;
        let y = rescale(c[i], 1, -1, miny, maxy);
        ctx?.lineTo(x, y);
      }
      ctx?.stroke();
      ci++;
    }
    return canvas;
  }

  // demos-src/audio.demo.ts
  var track = silence(6);
  var impulseRes = add(
    silence(6),
    signal(3, (x, i) => i % 1400 === 0 ? (x / 3) ** 4 * 0.1 : 0),
    0
  );
  range(13).map((i) => {
    add(
      track,
      modulateGain(
        sine(0.25, 440 * 2 ** (i / 12), 0.5),
        scaleDuration(adsr(0.1, 0.1, 0.7, 0.1), 0.25)
      ),
      0 + i * 0.2
    );
  });
  var reverbed = convolve(track, impulseRes);
  document.body.appendChild(graphAudio(reverbed, 1e3, 200));
  (async () => {
  })();
  document.addEventListener("click", () => {
    console.log("playing");
    play(reverbed);
    setTimeout(() => {
      console.log("one second");
    }, 1e3);
  });
})();

  </script>
</body>
    